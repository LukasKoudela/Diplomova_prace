% !TeX root = Main.tex
\chapter{Programový kód simulačního modulu} \label{kap:Program_kod}
\section{Řešení Helmholtzovy rovnice (\ref{rce:sim_kar_helmholtz_num}) knihovnou Hermes2D}
\subsection*{Reálná část (\ref{rce:sim_kar_weak_real})}
Implementace bilineární části odpovídá následujícím zápisům
\begin{verbatim}
add_matrix_form(new WeakFormsMaxwell::VolumetricMatrixForms::DefaultLinearMagnetostatics(0, 0,
        QString::number(i).toStdString(),
        - 1.0 / (material->permeability.number * MU0),
        HERMES_NONSYM,
        convertProblemType(Util::scene()->problemInfo()->problemType),
        (Util::scene()->problemInfo()->problemType == ProblemType_Planar ? 0 : 3)));

add_matrix_form(new WeakFormsH1::VolumetricMatrixForms::DefaultLinearMass(0, 0,
        QString::number(i).toStdString(),
        sqr(2 * M_PI * Util::scene()->problemInfo()->frequency) *
                                                     (material->permittivity.number * EPS0),
        HERMES_NONSYM,
        HERMES_PLANAR));
  
add_matrix_form(new WeakFormsH1::VolumetricMatrixForms::DefaultLinearMass(0, 1,
        QString::number(i).toStdString(),
        2 * M_PI * Util::scene()->problemInfo()->frequency * material->conductivity.number,
        HERMES_NONSYM,
        HERMES_PLANAR));
\end{verbatim}
Lineární člen na pravé straně rovnice je potřeba zapsat ve tvaru
\begin{verbatim}
add_vector_form(new WeakFormsH1::VolumetricVectorForms::DefaultVectorFormConst(0,
        QString::number(i).toStdString(),
        2 * M_PI * Util::scene()->problemInfo()->frequency * 
                                                  material->current_density_imag.number,
        HERMES_PLANAR));
\end{verbatim}

\subsection*{Imaginární část (\ref{rce:sim_kar_weak_imag})}
Složky kódu s~indexy \uv{imag\_real} a \uv{imag\_imag} jsou zapsány
\begin{verbatim}
add_matrix_form(new WeakFormsMaxwell::VolumetricMatrixForms::DefaultLinearMagnetostatics(1, 1,
       QString::number(i).toStdString(),
       - 1.0 / (material->permeability.number * MU0),
       HERMES_NONSYM,
       convertProblemType(Util::scene()->problemInfo()->problemType),
       (Util::scene()->problemInfo()->problemType == ProblemType_Planar ? 0 : 3)));


add_matrix_form(new WeakFormsH1::VolumetricMatrixForms::DefaultLinearMass(1, 1,
       QString::number(i).toStdString(),
       sqr(2 * M_PI * Util::scene()->problemInfo()->frequency) *
                                                    (material->permittivity.number * EPS0),
       HERMES_NONSYM,
       HERMES_PLANAR));
       
add_matrix_form(new WeakFormsH1::VolumetricMatrixForms::DefaultLinearMass(1, 0,
       QString::number(i).toStdString(),
       - 2 * M_PI * Util::scene()->problemInfo()->frequency * material->conductivity.number,
       HERMES_NONSYM,
       HERMES_PLANAR));
\end{verbatim}
Nakonec lineární člen imaginární části řešené rovnice je implemetován zápisem
\begin{verbatim}
add_vector_form(new WeakFormsH1::VolumetricVectorForms::DefaultVectorFormConst(1,
       QString::number(i).toStdString(),
       - 2 * M_PI * Util::scene()->problemInfo()->frequency * 
                                                   material->current_density_real.number,
       HERMES_PLANAR));
\end{verbatim}


\section{Kód okrajových podmínek}
Při řešení problémů vztahující se k~elektromagnetickému poli je možné použít na řešenou oblast několik typů okrajových podmínek, které se zadávají v~dialogu \uv{new boundary condition}. 

\subsection*{Elektrické pole}
Programový kód, který přísluší k~zadáni Dirichletovy podmínky na hranici $\Gamma$, je v~modulu zapsán následovně
\begin{verbatim}
Dirichlet
\end{verbatim}

\subsubsection*{Povrchová proudová hustota}
\begin{verbatim}
if (boundary->type == PhysicFieldBC_RF_SurfaceCurrent)
{
    if (fabs(boundary->value_imag.number) > EPS_ZERO)
        add_vector_form_surf(new WeakFormsH1::SurfaceVectorForms::DefaultVectorFormSurf(0,
                QString::number(i + 1).toStdString(),
                - 2 * M_PI * Util::scene()->problemInfo()->frequency * boundary->value_imag.number,
                HERMES_PLANAR));
    if (fabs(boundary->value_real.number) > EPS_ZERO)
        add_vector_form_surf(new WeakFormsH1::SurfaceVectorForms::DefaultVectorFormSurf(1,
                QString::number(i + 1).toStdString(),
                2 * M_PI * Util::scene()->problemInfo()->frequency * boundary->value_real.number,
                HERMES_PLANAR));
}
\end{verbatim}

\subsubsection*{Impedančně přizpůsobená hranice}
Programovému zápisu pro registraci a zápis slabých forem odpovídá
\begin{verbatim}
add_matrix_form_surf(new CustomMatrixFormSurfMatchedBoundary(0, 1,
       QString::number(i + 1).toStdString(),
       1.0,
       2 * M_PI * Util::scene()->problemInfo()->frequency));
       
add_matrix_form_surf(new CustomMatrixFormSurfMatchedBoundary(1, 0,
       QString::number(i + 1).toStdString(),
       - 1.0,
       2 * M_PI * Util::scene()->problemInfo()->frequency));            
\end{verbatim}
Funkci \texttt{CustomMatrixFormSurfMatchedBoundary} je potřeba v modulu blíže definovat
\begin{verbatim}
class CustomMatrixFormSurfMatchedBoundary : public WeakForm::MatrixFormSurf
{
  public:
    CustomMatrixFormSurfMatchedBoundary(int i, int j, std::string area, 
                                         scalar coeff, scalar frequency)
      : WeakForm::MatrixFormSurf(i, j, area), coeff(coeff), frequency(frequency) { }

    virtual scalar value(int n, double *wt, Func<scalar> *u_ext[], Func<double> *u, 
                    Func<double> *v, Geom<double> *e, ExtData<scalar> *ext) const {
      
      SceneMaterialRF *material = dynamic_cast<SceneMaterialRF *>
                             (Util::scene()->labels[Util::scene()->sceneSolution()->
                             agrosMaterialMarker(e->elem_marker)]->material);

      double mu = material->permeability.number * MU0;
      double eps = material->permittivity.number * EPS0;
      double conductivity = material->conductivity.number;

      return coeff * sqrt((eps - conductivity / frequency) / mu) * 
                              int_u_v<double, scalar>(n, wt, u, v);
    }

    virtual Ord ord(int n, double *wt, Func<Ord> *u_ext[], Func<Ord> *u,
                        Func<Ord> *v, Geom<Ord> *e, ExtData<Ord> *ext) const {
    
      return int_u_v<Ord, Ord>(n, wt, u, v);
    }

        // This is to make the form usable in rk_time_step().
    virtual WeakForm::MatrixFormSurf* clone() {

      return new CustomMatrixFormSurfMatchedBoundary(*this);
    }

    private:
        scalar coeff, frequency;
};
\end{verbatim}

\section{Zobrazení veličin postprocessingu}
\subsection*{Intenzita elektrického pole}
Programová implementace pro elektrickou složku pole v~kartézských souřanicích je v~modulu zajištěn ve funkci \texttt{ViewScalarFilterRF} pomocí následujícího kódu, neboť se jedná o~přímé řešení výchozí rovnice (\ref{rce:sim_helmholtz_vychozi} )
\begin{verbatim}
case PhysicFieldVariable_RF_ElectricField:
{
    node->values[0][0][i] = sqrt(sqr(value1[i]) + sqr(value2[i]));
}    
\end{verbatim}
kde je patrná reálná složka elektrického pole, jejíž samostatný zápis v~modulu je
\begin{verbatim}
case PhysicFieldVariable_RF_ElectricFieldReal:
{
    node->values[0][0][i] = value1[i];
}    
\end{verbatim}
a obdobně imaginární složka 
\begin{verbatim}
case PhysicFieldVariable_RF_ElectricFieldImag:
{    
    node->values[0][0][i] = value2[i];
}
\end{verbatim}

\subsection*{Magnetická indukce}
Reálná část magnetické indukce ve směru $x$ je ve funkci \texttt{ViewScalarFilterRF} zapsána programovým kódem
\begin{verbatim}
case PhysicFieldVariable_RF_MagneticFluxDensityXReal:
{
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = -(1/(w)) * dudy2[i];
}
\end{verbatim}
Analogickým způsobem je možné popsat imaginární část
\begin{verbatim}
case PhysicFieldVariable_RF_MagneticFluxDensityXImag:
{
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = (1/(w)) * dudy1[i];
}    
\end{verbatim}
Dále je potřeba zapsat implementaci kódu pro magnetickou indukci ve směru $y$
\begin{verbatim}
case PhysicFieldVariable_RF_MagneticFluxDensityYReal:
{
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = (1/(w)) * dudx2[i];
}
\end{verbatim}
\begin{verbatim}
case PhysicFieldVariable_RF_MagneticFluxDensityYImag:
{
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = -(1/(w)) * dudx1[i];
}
\end{verbatim}
Nakonec zbývá vyjádřit rozložení vektoru magnetické indukce, což je možné v~programovém kódu zapsat takto
\begin{verbatim}
case PhysicFieldVariable_RF_MagneticFluxDensity:
{
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = sqrt(sqr(-(1/(w)) * dudy2[i]) + sqr((1/(w)) * dudy1[i])
                               + sqr((1/(w)) * dudx2[i]) + sqr(-(1/(w)) * dudx1[i]));
}
\end{verbatim}

\subsection*{Intenzita magnetického pole}
Pro úplnost je níže uveden kód pro reálnou složku intenzity magnetického pole ve směru $x$, tj. $H_{x\Re}$
\begin{verbatim}
case PhysicFieldVariable_RF_MagneticFieldXReal:
{
    SceneMaterialRF *marker = dynamic_cast<SceneMaterialRF *>(material);
    double mu = marker->permeability.number * MU0;
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = -(1/(w*mu)) * dudy2[i];
}
\end{verbatim}

\subsection*{Poyntingův vektor}
Programový kód pro rozložení Poyntingova vektoru ve směru $x$ je v~modulu zapsán takto
\begin{verbatim}
case PhysicFieldVariable_RF_PoyntingVectorX:
{
    SceneMaterialRF *marker = dynamic_cast<SceneMaterialRF *>(material);
    double mu = marker->permeability.number * MU0;
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = - 0.5 * ((value2[i] * 1/(w*mu) * dudx1[i]) 
                                   - (value1[i] * 1/(w*mu) * dudx2[i]));
}
\end{verbatim}
Pro Poyntingův vektor ve směru $y$ analogicky platí
\begin{verbatim}
case PhysicFieldVariable_RF_PoyntingVectorY:
{
    SceneMaterialRF *marker = dynamic_cast<SceneMaterialRF *>(material);
    double mu = marker->permeability.number * MU0;
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = 0.5 * ((value2[i] * 1/(w*mu) * dudy1[i]) 
                                 - (value1[i] * 1/(w*mu) * dudy2[i]));
}
\end{verbatim}
Pro výslednou hodnotu Poyntingova vektoru na řešené oblasti $\Omega$ platí
\begin{verbatim}
case PhysicFieldVariable_RF_PoyntingVector:
{
    double mu = marker->permeability.number * MU0;
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = 0.5 * sqrt(sqr(((value2[i] * 1/(w*mu) * dudx1[i]) 
                                          - (value1[i] * 1/(w*mu) * dudx2[i]))) 
                                     + sqr(((value2[i] * 1/(w*mu) * dudy1[i]) 
                                          - (value1[i] * 1/(w*mu) * dudy2[i]))));
}
\end{verbatim}

\subsection*{Jouleovy ztráty}
Zápis kódu má následující charakter
\begin{verbatim}
case PhysicFieldVariable_RF_PowerLosses:
{
    double sigma = (marker->conductivity.number);
    node->values[0][0][i] = 0.5 * (sqr(value1[i]) + sqr(value2[i])) * sigma;
}
\end{verbatim}
