% !TeX root = Main.tex
\chapter{Programový kód simulačního modulu} \label{kap:Program_kod}
\section{Řešení Helmholtzovy rovnice (\ref{rce:sim_kar_helmholtz_num}) knihovnou Hermes2D}
\subsubsection*{Reálná část (\ref{rce:sim_kar_weak_real})}
Implementace bilineární části odpovídá následujícím zápisům
\begin{verbatim}
template<typename Real, typename Scalar>
Scalar rf_matrix_form_real_real(int n, double *wt, Func<Real> *u_ext[], Func<Real> *u,
                                    Func<Real> *v, Geom<Real> *e, ExtData<Scalar> *ext)
{
    return - int_grad_u_grad_v<Real, Scalar>(n, wt, u, v)
    + sqr(2 * M_PI * frequency) * (rfLabel[e->elem_marker].permeability * MU0)
    * (rfLabel[e->elem_marker].permittivity * EPS0) * int_u_v<Real, Scalar>(n, wt, u, v);
}

template<typename Real, typename Scalar>
Scalar rf_matrix_form_real_imag(int n, double *wt, Func<Real> *u_ext[], Func<Real> *u,
                                     Func<Real> *v, Geom<Real> *e, ExtData<Scalar> *ext)
{
    return + 2 * M_PI * frequency * (rfLabel[e->elem_marker].permeability * MU0) 
    * rfLabel[e->elem_marker].conductivity * int_u_v<Real, Scalar>(n, wt, u, v);
}

\end{verbatim}
Lineární člen na pravé straně rovnice je potřeba zapsat ve tvaru
\begin{verbatim}
template<typename Real, typename Scalar>
Scalar rf_vector_form_real(int n, double *wt, Func<Real> *u_ext[], Func<Real> *v,
                                              Geom<Real> *e, ExtData<Scalar> *ext)
{
    Scalar result = 0 ;
    int u = 0;
    for (int i = 0; i < n; i++)
        result += wt[i] * (rfLabel[e->elem_marker].current_density_imag * v->val[i]);

    return - 2 * M_PI * frequency * (rfLabel[e->elem_marker].permeability * MU0) * result;
}
\end{verbatim}

\subsubsection*{Imaginární část (\ref{rce:sim_kar_weak_imag})}
Složky kódu s indexy \uv{imag\_real} a \uv{imag\_imag} jsou zapsána
\begin{verbatim}
template<typename Real, typename Scalar>
Scalar rf_matrix_form_imag_real(int n, double *wt, Func<Real> *u_ext[], Func<Real> *u,
									Func<Real> *v, Geom<Real> *e, ExtData<Scalar> *ext)
{
    return - 2 * M_PI * frequency * (rfLabel[e->elem_marker].permeability * MU0) 
    * rfLabel[e->elem_marker].conductivity * int_u_v<Real, Scalar>(n, wt, u, v);
}

template<typename Real, typename Scalar>
Scalar rf_matrix_form_imag_imag(int n, double *wt, Func<Real> *u_ext[], Func<Real> *u,
                                    Func<Real> *v, Geom<Real> *e, ExtData<Scalar> *ext)
{
    return - int_grad_u_grad_v<Real, Scalar>(n, wt, u, v) 
    + sqr(2 * M_PI * frequency) * (rfLabel[e->elem_marker].permeability * MU0) 
    * (rfLabel[e->elem_marker].permittivity * EPS0) * int_u_v<Real, Scalar>(n, wt, u, v);
}
\end{verbatim}
Nakonec lineární člen imaginární části řešené rovnice je implemetován zápisem
\begin{verbatim}
template<typename Real, typename Scalar>
Scalar rf_vector_form_imag(int n, double *wt, Func<Real> *u_ext[], Func<Real> *v,
                                              Geom<Real> *e, ExtData<Scalar> *ext)
{
    Scalar result = 0 ;
    int u = 0;
    for (int i = 0; i < n; i++)
        result += wt[i] * (rfLabel[e->elem_marker].current_density_real * v->val[i]);

    return 2 * M_PI * frequency * (rfLabel[e->elem_marker].permeability * MU0) * result;
}
\end{verbatim}
\subsubsection*{Registrace forem}
Zmíněné funkce pro řešení Helmholtzovy rovnice (\ref{rce:sim_kar_helmholtz_num}) je dále potřeba zaregistrovat ve třídě \textsc{WeakForm} následujícím způsobem
\begin{verbatim}
wf->add_matrix_form(0, 0, callback(rf_matrix_form_real_real));
wf->add_matrix_form(0, 1, callback(rf_matrix_form_real_imag));
wf->add_matrix_form(1, 0, callback(rf_matrix_form_imag_real));
wf->add_matrix_form(1, 1, callback(rf_matrix_form_imag_imag));
wf->add_vector_form(0, callback(rf_vector_form_real))
wf->add_vector_form(1, callback(rf_vector_form_imag));
\end{verbatim}

\section{Kód okrajových podmínek}
Při řešení problémů vztahující se k elektromagnetickému poli je možné použít na řešenou oblast několik typů okrajových podmínek, které se zadávají v dialogu \uv{new boundary condition}. 

\subsubsection*{Electric field}
Programový kód, který přísluší k zadáni Dirichletovy podmínky na hranici $\Gamma$, je v modulu zapsán nastavením tříd \textsc{BCTypes} a \textsc{BCValues} následovně
\begin{verbatim}
BCTypes bcTypesReal, bcTypesImag;
bcTypesReal.add_bc_dirichlet(i+1);
bcTypesImag.add_bc_dirichlet(i+1);
                
BCValues bcValuesReal, bcValuesImag;
bcValuesReal.add_const(i+1, edgeRFMarker->value_real.number);
bcValuesImag.add_const(i+1, edgeRFMarker->value_imag.number);
\end{verbatim}

\subsubsection*{Magnetic field}
Touto volbou zadáváme hodnotu normálové derivace funkce $\frac{\partial E_{(z)}}{\partial n}$, jenž představuje Neumannovu okrajovou podmínku na hranici $\Gamma$. Opět má charakter komplexní veličiny, ve slabých formách vyjádřených v (\ref{rce:sim_kar_weak_real} ) a (\ref{rce:sim_kar_weak_imag}) podmínka představuje členy $\int_{\Gamma}\frac{\partial E_R}{\partial n}\cdot v\dif l$, případně $\int_{\Gamma}\frac{\partial E_I}{\partial n}\cdot v\dif l$. Příslušný kód je zapsán třídou \textsc{BCTypes}
\begin{verbatim}
BCTypes bcTypesReal, bcTypesImag;
bcTypesReal.add_bc_neumann(i+1);
bcTypesImag.add_bc_neumann(i+1);               
\end{verbatim}
a funkcí vracející povrchovou lineární formu Neumannovy okrajové podmínky. V případě nulové Neumannovy okrajové podmínky však lze danou funkci vynechat, tak jako v tomto případě.

\subsubsection*{Matched boundary}
Ve výpočtu se tedy jedná se o Newtonovu okrajovou podmínku ve tvaru
\begin{equation}
	\bigg(\frac{\partial E_{(z)}}{\partial n} - \mj\beta E_{(z)}\bigg)|_{\Gamma} = 0.
	\label{rce:sim_BC_matched_boundary}
\end{equation}
Pro její implementaci je potřeba nastavit třídu \textsc{BCTypes} následovně
\begin{verbatim}
BCTypes bcTypesReal, bcTypesImag;
bcTypesReal.add_bc_newton(i+1);
bcTypesImag.add_bc_newton(i+1);              
\end{verbatim}
a také zapsat funkce pro povrchové bilineární formy. Pro reálnou složku odpovídá 
\begin{verbatim}
template<typename Real, typename Scalar>
Scalar rf_matrix_form_surf_imag_real(int n, double *wt, Func<Real> *u_ext[], Func<Real> *u,
                                         Func<Real> *v, Geom<Real> *e, ExtData<Scalar> *ext)
{
    if (!(rfEdge[e->edge_marker].type == PhysicFieldBC_RF_MatchedBoundary ||
          rfEdge[e->edge_marker].type == PhysicFieldBC_RF_Port))
    return 0.0;

    double mu = rfLabel[e->elem_marker].permeability * MU0;
    double eps = rfLabel[e->elem_marker].permittivity * EPS0;
    double height = rfEdge[e->edge_marker].height;
    double beta = 0.0;
    double Z = 0.0;

    if(!rfEdge[e->edge_marker].height == 0)
    {
        beta = sqrt(sqr(2 * M_PI * frequency) * mu * eps - sqr(1 * M_PI / height));
        return beta * int_u_v<Real, Scalar>(n, wt, u, v);
    }
    else
    {
        beta = sqrt(sqr(2 * M_PI * frequency) * mu * eps);
        Z = ((2 * M_PI * frequency) * mu ) / beta;
        return Z * int_u_v<Real, Scalar>(n, wt, u, v);
    }
}
\end{verbatim}
Pro imaginární část okrajové podmínky platí
\begin{verbatim}
template<typename Real, typename Scalar>
Scalar rf_matrix_form_surf_real_imag(int n, double *wt, Func<Real> *u_ext[], Func<Real> *u,
                                         Func<Real> *v, Geom<Real> *e, ExtData<Scalar> *ext)
{
    if (!(rfEdge[e->edge_marker].type == PhysicFieldBC_RF_MatchedBoundary ||
          rfEdge[e->edge_marker].type == PhysicFieldBC_RF_Port))
    return 0.0;

    double mu = rfLabel[e->elem_marker].permeability * MU0;
    double eps = rfLabel[e->elem_marker].permittivity * EPS0;
    double height = rfEdge[e->edge_marker].height;
    double beta = 0.0;
    double Z = 0.0;

    if(!rfEdge[e->edge_marker].height == 0)
    {
        beta = sqrt(sqr(2 * M_PI * frequency) * mu * eps - sqr(1 * M_PI / height));
        return beta * int_u_v<Real, Scalar>(n, wt, u, v);
    }
    else
    {
        beta = sqrt(sqr(2 * M_PI * frequency) * mu * eps);
        Z = ((2 * M_PI * frequency) * mu ) / beta;
        return Z * int_u_v<Real, Scalar>(n, wt, u, v);
    }
}
\end{verbatim}
Lineární část je u vztahu (\ref{rce:sim_BC_matched_boundary}) nulová, proto lze funkci pro její zápis vynechat.
Nakonec je potřeba výše uvedené funkce zaregistrovat ve třídě \textsc{WeakForm} takto
\begin{verbatim}
wf->add_vector_form_surf(0, callback(rf_vector_form_surf_real));
wf->add_vector_form_surf(1, callback(rf_vector_form_surf_imag));           
\end{verbatim}
                
\subsubsection*{Port}

\section{Programový zápis pro zobrazení výsledků řešení}
\subsection*{Electric field}
Programová implementace pro elektrickou složku pole v kartézských souřanicích je v modulu zajištěn ve funkci \texttt{ViewScalarFilterRF} pomocí následujícího kódu, neboť se jedná o přímé řešení výchozí rovnice (\ref{rce:sim_helmholtz_vychozi} )
\begin{verbatim}
case PhysicFieldVariable_RF_ElectricField:
{
    node->values[0][0][i] = sqrt(sqr(value1[i]) + sqr(value2[i]));
}    
\end{verbatim}
kde je patrná reálná složka elektrického pole, jejíž samostatný zápis v modulu je
\begin{verbatim}
case PhysicFieldVariable_RF_ElectricFieldReal:
{
    node->values[0][0][i] = value1[i];
}    
\end{verbatim}
a obdobně imaginární složka 
\begin{verbatim}
case PhysicFieldVariable_RF_ElectricFieldImag:
{    
    node->values[0][0][i] = value2[i];
}
\end{verbatim}

\subsection*{Magnetická indukce}
Reálná část magnetické indukce ve směru $x$ je ve funkci \texttt{ViewScalarFilterRF} zapsána programovým kódem
\begin{verbatim}
case PhysicFieldVariable_RF_MagneticFluxDensityXReal:
{
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = -(1/(w)) * dudy2[i];
}
\end{verbatim}
Analogickým způsobem je možné popsat imaginární část
\begin{verbatim}
case PhysicFieldVariable_RF_MagneticFluxDensityXImag:
{
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = (1/(w)) * dudy1[i];
}    
\end{verbatim}
Dále je potřeba zapsat implementaci kódu pro magnetickou indukci ve směru $y$
\begin{verbatim}
case PhysicFieldVariable_RF_MagneticFluxDensityYReal:
{
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = (1/(w)) * dudx2[i];
}
\end{verbatim}
\begin{verbatim}
case PhysicFieldVariable_RF_MagneticFluxDensityYImag:
{
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = -(1/(w)) * dudx1[i];
}
\end{verbatim}
Nakonec zbývá vyjádřit rozložení vektoru magnetické indukce, což je možné v programovém kódu zapsat takto
\begin{verbatim}
case PhysicFieldVariable_RF_MagneticFluxDensity:
{
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = sqrt(sqr(-(1/(w)) * dudy2[i]) + sqr((1/(w)) * dudy1[i])
                               + sqr((1/(w)) * dudx2[i]) + sqr(-(1/(w)) * dudx1[i]));
}
\end{verbatim}

\subsection*{Magnetic field}
Pro úplnost je níže uveden kód pro reálnou složku intenzity magnetického pole ve směru $x$, tj. $H_{x\Re}$
\begin{verbatim}
case PhysicFieldVariable_RF_MagneticFieldXReal:
{
    SceneMaterialRF *marker = dynamic_cast<SceneMaterialRF *>(material);
    double mu = marker->permeability.number * MU0;
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = -(1/(w*mu)) * dudy2[i];
}
\end{verbatim}

\subsection*{Poyntingův vektor}
Programový kód pro rozložení Poyntingova vektoru ve směru $x$ je v modulu zapsán takto
\begin{verbatim}
case PhysicFieldVariable_RF_PoyntingVectorX:
{
    SceneMaterialRF *marker = dynamic_cast<SceneMaterialRF *>(material);
    double mu = marker->permeability.number * MU0;
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = - 0.5 * ((value2[i] * 1/(w*mu) * dudx1[i]) 
                                   - (value1[i] * 1/(w*mu) * dudx2[i]));
}
\end{verbatim}
Pro Poyntingův vektor ve směru $y$ analogicky platí
\begin{verbatim}
case PhysicFieldVariable_RF_PoyntingVectorY:
{
    SceneMaterialRF *marker = dynamic_cast<SceneMaterialRF *>(material);
    double mu = marker->permeability.number * MU0;
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = 0.5 * ((value2[i] * 1/(w*mu) * dudy1[i]) 
                                 - (value1[i] * 1/(w*mu) * dudy2[i]));
}
\end{verbatim}
Pro výslednou hodnotu Poyntingova vektoru na řešené oblasti $\Omega$ platí
\begin{verbatim}
case PhysicFieldVariable_RF_PoyntingVector:
{
    double mu = marker->permeability.number * MU0;
    double w = 2 * M_PI * Util::scene()->problemInfo()->frequency;
    node->values[0][0][i] = 0.5 * sqrt(sqr(((value2[i] * 1/(w*mu) * dudx1[i]) 
                                          - (value1[i] * 1/(w*mu) * dudx2[i]))) 
                                     + sqr(((value2[i] * 1/(w*mu) * dudy1[i]) 
                                          - (value1[i] * 1/(w*mu) * dudy2[i]))));
}
\end{verbatim}

\subsection*{Jouleovy ztráty}
Zápis kódu má následující charakter
\begin{verbatim}
case PhysicFieldVariable_RF_PowerLosses:
{
    double sigma = (marker->conductivity.number);
    node->values[0][0][i] = 0.5 * (sqr(value1[i]) + sqr(value2[i])) * sigma;
}
\end{verbatim}
